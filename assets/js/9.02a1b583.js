(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{496:function(t,e,v){t.exports=v.p+"assets/img/eventloop01.ae0928a6.png"},497:function(t,e,v){t.exports=v.p+"assets/img/eventloop02.4759bfc6.png"},498:function(t,e,v){t.exports=v.p+"assets/img/eventloop03.d31855d7.png"},518:function(t,e,v){"use strict";v.r(e);var o=v(6),n=Object(o.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("blockquote",[o("p",[t._v("学习Event loop之前建议先去了解一下"),o("RouterLink",{attrs:{to:"/blogs/Js/10-js.html"}},[t._v("微任务与宏任务")])],1)]),t._v(" "),o("p",[t._v("在Event Loop中，每一次循环称为tick，每一次tick的任务如下：")]),t._v(" "),o("ul",[o("li",[t._v("执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；")]),t._v(" "),o("li",[t._v("检查是否存在微任务，有则会执行至微任务队列为空；")]),t._v(" "),o("li",[t._v("如果宿主为浏览器，可能会渲染页面；")]),t._v(" "),o("li",[t._v("开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。\n"),o("img",{attrs:{src:v(496),alt:"eventloop1"}})])]),t._v(" "),o("h3",{attrs:{id:"事件循环机制"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#事件循环机制"}},[t._v("#")]),t._v(" 事件循环机制")]),t._v(" "),o("p",[t._v("单线程的运行环境有且只有一个"),o("code",[t._v("call-stack")]),t._v("调用栈(执行栈)，所有的任务(代码)都会被放到调用栈等待浏览器的主线程执行。")]),t._v(" "),o("p",[t._v("此时"),o("code",[t._v("整体代码script")]),t._v("作为第一个宏任务开始执行，执行到异步代码时会先把异步代码放到"),o("code",[t._v("event Table/webapi")]),t._v("注册，注册之后根据异步代码选择放入微任务/宏任务的event queue，同时继续执行主线程中的同步代码。")]),t._v(" "),o("p",[t._v("整体代码执行完之后event loop会先检查微任务Event Queue队列中有没有回调函数，如果有就将它放到执行栈中执行(执行完一个函数检查一次队列，如果队列还有函数就再继续执行下一个一个函数，以此类推队列的函数一个一个执行)，执行完微任务Event Queue后第一轮事件循环就结束了。")]),t._v(" "),o("p",[t._v("第二轮循环事件开始，先从宏任务开始，发现宏任务Event Queue中有上一轮保存的回调函数，立即执行，执行完检查该回调函数中有没有微任务，有就放入微任务Eevent Queue，执行完宏任务之后就又执行刚刚放入的微任务，结束\n后续如果有嵌套更多的微/宏任务就继续像上面一样循环，直到执行完所有代码\n"),o("img",{attrs:{src:v(497),alt:"peventloop2"}}),t._v(" "),o("img",{attrs:{src:v(498),alt:"eventloop3"}})])])}),[],!1,null,null,null);e.default=n.exports}}]);