(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{548:function(l,e,t){"use strict";t.r(e);var s=t(6),o=Object(s.a)({},(function(){var l=this,e=l.$createElement,t=l._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[t("h3",{attrs:{id:"select、poll和epoll的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#select、poll和epoll的区别"}},[l._v("#")]),l._v(" select、poll和epoll的区别")]),l._v(" "),t("p",[l._v("三者都是I/O多路复用技术，即一个线程利用它们可以同时处理多个socket\nI/O多路复用技术：可以避免非阻塞I/O模型轮询对计算资源的浪费以及阻塞I/O模型的低效")]),l._v(" "),t("ol",[t("li",[l._v("select：通过调用 select 函数，进程可以同时监听多个文件描述符的读写事件，一旦其中一个文件描述符就绪（有数据可读或可写），select 函数就会返回")])]),l._v(" "),t("blockquote",[t("p",[l._v("每次调用select都需要所有被监听的文件描述符从用户态拷贝到内核态，可能导致性能问题。每次拷贝的文件描述符数量的限制大小一般只有1024")])]),l._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[l._v("poll：与select类似，没有文件描述符数量的限制，但是仍然需要所有监听的文件描述符从用户态拷贝到内核态")])]),l._v(" "),t("li",[t("p",[l._v("epoll：epoll 采用了回调机制，它在内核态维护一个事件表，只有当文件描述符就绪时，内核会将就绪的文件描述符加入到一个就绪列表中，用户态程序可以直接获取就绪的文件描述符，避免了不必要的拷贝操作。")])])])])}),[],!1,null,null,null);e.default=o.exports}}]);