(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{546:function(t,e,o){"use strict";o.r(e);var n=o(6),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h3",{attrs:{id:"锁的粒度"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#锁的粒度"}},[t._v("#")]),t._v(" 锁的粒度")]),t._v(" "),o("p",[t._v("锁的粒度指的是锁定共享资源的粒度大小。锁的粒度大小直接影响到程序的并发性和性能。")]),t._v(" "),o("blockquote",[o("p",[t._v("粒度可以理解为锁定的资源的大小")])]),t._v(" "),o("ul",[o("li",[t._v("锁的粒度过粗，即锁定了较大的共享资源，会导致并发性下降，因为多个goroutine需要等待锁才能访问共享资源。同时，当某个goroutine需要修改共享资源时，会锁定整个共享资源，导致其他goroutine也需要等待锁，从而造成性能瓶颈。因此，在锁的粒度过粗时，程序的并发性和性能都会受到影响。")]),t._v(" "),o("li",[t._v("锁的粒度过细，即锁定了较小的共享资源，会导致频繁地获取和释放锁，因为多个goroutine可能同时访问共享资源的不同部分，需要获取不同的锁。频繁地获取和释放锁会增加锁争用的次数，从而降低程序的性能。同时，如果锁的粒度过细，还可能会导致死锁的发生。因此，在锁的粒度过细时，程序的并发性和性能也会受到影响。")])]),t._v(" "),o("blockquote",[o("p",[t._v("我们应该选择合适的锁粒度来平衡并发性和性能。通常情况下，我们可以将锁的粒度控制在合适的范围内，以提高程序的并发性和性能。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);